- #[[Data Structure]]
- # Graph theory
	- A study of networks of vertices (nodes), connected by edges
- # Properties
	- ## Direction
		- *Undirected graph* edge has no orientation, and the edge is usually denoted $(u, v)$ which means there's a connection between noode $u$ and $v$
		- For undirected graphs, edges $(u, v) = (v, u)$
		- If the edge has some orientation/direction, then we call it a *directed graph*
	- ## Weight
		- If the edge has some form of weight, then it's a weighted graph
		- Weight could be positive only, or sometimes a negative weight is allowed
		- For weighted graph, edge is usually denoted $(u, v, w)$
	- ## Cycle
		- A cyclic graph has nodes that can be reached again
		- A acyclic graph has no circles - once we visit a node, we can't reach it again
- # Problems
	- ## Find connectivity
		- Whether $node_i$ could be reachable by $node_j$
	- ## Find best routes
		- **Smallest hops** for unweighted graphs
		- **Cheapest path** for weighted graphs
	- ## Find cycles
		- #### Detect negative cycles
			- Negative cycles might be problematic - because we keep getting cheaper and cheaper paths. Some algo, e.g. Djikstra, prohibits negative weight
			- **Negative cycles are valid or even desirable in some use case**, e.g. finding currency swap arbitrage opportunities
- # Types of graphs
	- ## Tree
		- Trees are *acyclic undirected* graphs
		- > Any undirected graphs are trees in this sense, **although when we talk about trees we generally refer to the rootedd trees**
		- ### Rooted trees
			- Rooted trees are trees with root noode at the top
			- All nodes, except the root, can have only 1 parent
			- Trees are ubiquitous in CS, and some types of tree are in use almost everywhere, e.g. the [[Binary tree]] and [[B-Tree]]
			- Trees usually are graphs with $N$ nodes and $N-1$ edge
	- ## Directed acyclic graphs (DAG)
		- Directed graphs with no cycles
		- Usually used to describe dependencies
		- e.g. Apache Beam pipelines, college course prerequisites, booting OS, etc.
	- ## Bipartite graphs
		- Nodes can be spit into 2 independent groups $A$ and $B$
		- Every single edge connects a node from group $a$ to a node in group $b$
			- $(u, v \mid u \in A$ and $v \in b)$
		- Example use case is in network flows
	- ## Complete graphs
		- Each node has edges to all other nodes
		- Usually bad because they are very dense
- # Representing graphs
	- ## Adjacency matrix
		- Adjacency matrix $m$ is a matrix such that cell $m[i][j]$ represent edge between $node_i$ to $node_j$.
			- For unweighted graphs, the cell values could be $1$ (connection) or $0$ (no connection)
			- For weighted graphs, the cell value $m[i][j]$ could be the weight value from $node_i$ to $node_j$
		- It is usually assumed that an edge going from a node to itself has $0$ value
		- **Nice for dense graphs**, because we can access edges in constant time
		- Bad for not-so-dense graphs
			- It takes $O(V^2)$ time to iterate through all edges
			- It requires $O(V^2)$ space for graphs with $V$ nodes
	- ## Adjacency list
		- Map graphs from a node to list of edges
			- e.g. using `map[node][]edges`in Go
		- **Nice for sparse graphs**, because we *only* store the edges we have
			- Good for iterating through all edges
		- **Bad for dense graphs**, because we now have to duplicate the edges
			- Edge lookup takes $O(E)$
	- ## Edge list
		- Represent graphs as unordered list of edges
		- Each edge is a triplet tuple $(u, v, w)$
		- e.g. this list `[(a, b, 1), (b, c, 2), (a, c, 7), (c, a, 3)]` for a directed graph with 3 nodes and 4 edges