- > Let $G$ be a CFG, then $L(G) =$ language of all strings generated by $G$
- ## Definition $G = (V, \Sigma, R, S)$
	- $V$ finite set of variables
	- $\Sigma$ finite set of terminal symbols
	- $R$ finite set of rules
	- $S$ a start variable
	- ### For $u, v \in (V \cup \Sigma)^\ast$
		- $u \Rightarrow v$ if can go from $u$ to $v$ with one step in $G$
		- $u \xRightarrow{\ast} v$ if can go with some number of substitutions
			- $u \Rightarrow u_1 \Rightarrow u_2 \Rightarrow \dots \Rightarrow v$ is called a derivation of $v$ from $u$
	- Then the definition of the language is $L(G) = \{w \mid w \in \Sigma^\ast$ and $S \xRightarrow{\ast} w\}$
- ## Overview
	- ### Components
		- **Variables** -> symbols that only appear on the LHS
		- **Terminals** -> symbols that only appear on c RHS
		- **Start variable** $S$ -> the root of all strings generated by this grammar
	- We generally expand $S$ into RHS until only terminals remain
		- $S \mapsto 0S1$
		  $S \mapsto R$
		  $R \mapsto \epsilon$
			- In this case, $S$ and $R$ are variables, with $S$ being start variable, and terminals $= \{0, 1, \epsilon\}$
			- This CFG can generate: $\{\epsilon, 01, 0011, 000111\}$, which is what [$\{0^k1^k \mid k \geq 0\}$](((65a173fb-af9f-49f8-9269-c92c2df58776))) describe
			- The generated strings are strings of the CFL
			- We can further *simplify* this grammar  by combining the 2 rules for $S$ :
			  $S \mapsto 0S1 \mid R$
			  $R \mapsto \epsilon$
			- Expansion steps for $0011$
			- {{renderer code_diagram,tikz}}
			  collapsed:: true
				- ```tikz
				  \usepackage{tikz}
				  \usetikzlibrary{positioning}
				  \begin{document}
				  \begin{tikzpicture}[
				  roundnode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},
				  squarednode/.style={rectangle, draw=blue!60, fill=red!5, very thick, minimum size=5mm},
				  ]
				  %Nodes
				  \node[roundnode]    (startvar)     {S};
				  
				  \node[roundnode]    (s1)           [below=of startvar] {S};
				  \node[squarednode]  (left0_0)      [left=of s1] {0};
				  \node[squarednode]  (right0_1)     [right=of s1 ] {1};
				  
				  \node[roundnode]    (s2)           [below=of s1] {S};
				  \node[squarednode]  (left1_0)      [left=of s2] {0};
				  \node[squarednode]  (right1_1)     [right=of s2] {1};
				  
				  \node[roundnode]    (r0)           [below=of s2] {R};
				  \node[squarednode]  (e)            [below=of r0] {$\epsilon$};
				  
				  %Lines
				  \draw[->] (startvar.south) -- (left0_0.north);
				  \draw[->] (startvar.south) -- (s1.north);
				  \draw[->] (startvar.south) -- (right0_1.north);
				  
				  \draw[->] (s1.south) -- (left1_0.north);
				  \draw[->] (s1.south) -- (s2.north);
				  \draw[->] (s1.south) -- (right1_1.north);
				  
				  \draw[->] (s2.south) -- (r0.north);
				  \draw[->] (r0.south) -- (e.north);
				  
				  \end{tikzpicture}
				  \end{document}
				  
				  ```